# leetcode patterns

- **Sliding Window** → Array, String, Linked List
  - Fixed-size window
  - Dynamic-size window (expand & contract)
  - Works well for: substring problems, maximum/minimum in a range, frequency tracking

- **Subset Pattern** → Array, Set
  - Backtracking
  - Bitmasking
  - Powerset generation

- **Binary Search** → Sorted Array, Monotonic Function, Matrix
  - Lower/Upper bound search
  - Search in rotated sorted array
  - Works well for: optimization problems, minimum/maximum search

- **Top K Elements** → Array, Heap (Priority Queue)
  - Min-heap / Max-heap
  - Quickselect (Hoare's Algorithm)
  - Works well for: frequent elements, Kth largest/smallest

- **Binary Tree DFS** → Binary Tree, Graph
  - Preorder, Inorder, Postorder traversal
  - Recursive & Iterative
  - Path sum, max depth, lowest common ancestor

- **Topological Sort** → Directed Acyclic Graph (DAG)
  - Kahn’s Algorithm (BFS)
  - DFS-based ordering
  - Works well for: course scheduling, dependency resolution

- **Binary Tree BFS** → Binary Tree, Graph
  - Level order traversal
  - Shortest path (unweighted graph)
  - Zigzag level order, connecting siblings

- **Two Pointer** → Sorted Array, Linked List
  - Opposite-direction (e.g., two sum)
  - Same-direction (e.g., remove duplicates)
  - Works well for: palindrome checking, merging intervals

- **Fast & Slow Pointers** → Linked List, Array
  - Cycle detection (Floyd’s algorithm)
  - Middle of linked list
  - Works well for: detecting cycles, finding duplicates

- **Backtracking** → Array, String, Matrix
  - Permutations & Combinations
  - Sudoku solver, N-Queens
  - Works well for: constraint-based problems

- **Union-Find (Disjoint Set)** → Graph
  - Connected components
  - Kruskal’s algorithm (MST)
  - Works well for: dynamic connectivity, network problems

- ** Queue** → Array, Stack
  - Next greater element
  - Largest rectangle in histogram
  - Works well for: range queries, maintaining order constraints

- **Trie (Prefix Tree)** → String
  - Word search
  - Auto-complete
  - Works well for: dictionary operations, prefix matching

- **Bit Manipulation** → Integers
  - XOR tricks (single number)
  - Subset generation
  - Works well for: performance optimizations, set operations

